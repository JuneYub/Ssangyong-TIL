## 1. 레이블 활용법

</br>
이중for문을 활용할 때 if문에서 break을 만든다면.
가장 가까운 반복문만을 탈출한다.

</br>

```
for(;;) { // 첫 번째 for문

    for(;;) { // 두 번째 for문
        if~
        else if~
    }
}
```

따라서 위 예시에서 두 번째 for문의 if문에서 첫 번째 for문까지 멈추고 싶다면 어떻게 해야할까?

</br>

```
labelTest:
for(;;) { // 첫 번째 for문

    for(;;) { // 두 번째 for문
        if() {
            break labelTest;
        }
        else if~
    }
}
```
labelTest라는 lable을 활용하여 첫번째 for문에 label을 만들어둠으로써 break label명으로 반복문을 종료시킬 수 있다.

</br>

#

## 2. 메모이제이션(Memoization)


</br>

동적계획법중의 하나인 재귀함수로 피보나치 수열을 구할 때 n번째 수를 구할려고 하면 탐색시간이 엄청 오래 걸린다.

그 이유는 재귀함수를 통해 탐색하는 과정에 이미 구한 F(4)를 2번,, F(3)를 3번,, 등등 구했던 겨로가를 반복해서 계산하기 때문이다.

이를 해결하기 위한 방법으로 중복을 제거하는 방법이 있다.

탐색을 하면서 이미 구한 값을 ```memo``` 배열을 이용하여 저장해놓고 활용하는 것이다.

방법
1. ```memo``` 배열을 처음에 전부 -1로 초기화 한다.(왜냐하면 우리는 피보나치 수열에서 -1이 없는 것을 알기 때문이다.)

2. ```memo``` 에 해당하는 값이 -1이라면 그 값을 계산해서 저장한다.

3. -1이 아니라면 이미 계산한 것이므로 값을 그대로 반환한다.

이를 통해서 O(2^n)을 O(n)으로 향상시킬 수 있다.


-------------------
</br>

## 3. 탑다운과 바텀업 방식

Memoization의 경우 높은 수(n번째 n-1, n-2 이런 식)에서 낮은 수로 내려가기 때문에 탑다운 방식이라고 하며 Tabulation 처럼 dp 배열의 모든 n을 구하기 위해서 for문을 돌면서 작은 수부터 n까지 채워나가는 방식을 바텀업 방식이라고 한다.

```
dp[] = {0,0,0,~}
dp[1] = 1
dp[2] = 2

for i=3...i <=n
    dp[i] = dp[i-1] + dp[i-2]
```